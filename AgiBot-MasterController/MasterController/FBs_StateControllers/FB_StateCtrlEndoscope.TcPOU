<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.11">
  <POU Name="FB_StateCtrlEndoscope" Id="{6b490525-446d-48f2-ab19-237faca074bd}" SpecialFunc="None">
    <Declaration><![CDATA[// Brief: Master Arm Endoscope Control
FUNCTION_BLOCK PUBLIC FB_StateCtrlEndoscope EXTENDS FB_MasterArmCtrlBase
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	// enter endoscope control for the first time
	m_firstIn :BOOL := TRUE;
	
	//arm force control in base coordinate
	m_impCtrlInBase:BOOL;
	
	// force control parameters in base coordinate
	m_kpBase:Vec6d:=[1,1,1,1,1,1];
	m_kdBase:Vec6d:=[0.01,0.01,0.01,0.01,0.01,0.01];
	
	//endoscope motion scale
	m_endoMotionScale:LREAL:=1;
	
	// force control parameters in tcp coordinate
	m_kpTcp:Vec6d:=[100,100,100,1,1,0.5];
	m_kdTcp:Vec6d:=[1,1,1,0.04,0.04,0.01]; //[5,5,5,0.04,0.04,0.01];
	
	//joint 6 KP/KD
	m_Kp6:LREAL:=1.0; //1
	m_Kd6:LREAL:=0.01; //0.01
	
	//expected joint 6 position
	m_ExpJ6Pos:LREAL;
	
	//time
	m_t:LREAL;	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[]]></ST>
    </Implementation>
    <Method Name="calcCmdJntPos" Id="{984a6e2e-69d6-4229-9915-1fa6625d4fbc}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntPos : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR
VAR 

END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[m_cmdJntPos:=i_masterArm.curJntPos;
m_cmdJntVel:=i_masterArm.curJntVel;
m_cmdCartPose:=i_masterArm.curCartPose;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="calcCmdJntTrq" Id="{cbe72b32-a8c6-44cd-81bf-77cb04776fee}">
      <Declaration><![CDATA[// override this function in each exact controller
METHOD PROTECTED calcCmdJntTrq : BOOL

VAR_IN_OUT CONSTANT
	i_slaveIdx :INT;
	i_shoulderPose :ST_Frame;
	i_masterArm :FB_MasterArm;
	i_slaveStatus :ST_SlaveStatus;
END_VAR

VAR	
	i:INT;
	
	//position variables
	masterPos,slavePos:ST_Frame;
	masterPosFirst,slavePosFirst:ST_Frame;
	ArmTarPos:ST_Frame;
	posInc:Vec3d;		
	tmpMat3d : Mat3d;
	rotInv:Mat3d;
	
	//velocity variables
	vel, velLocal, wVel,wVelLocal :Vec3d;
	spatialVel,spatialVelInTcp:Vec6d;
	
	//force variables
	spatialForceP1,spatialForceP2:Vec3d;	
	spatialForceP1Base,spatialForceP2Base:Vec3d;		
	spatialForTcp,spatialForBase,spatialForTemp:Vec7d;
	
	//joint torque variables
	simJaco:Mat67;
	JacoT :Mat76;	
	jntTorVec:Vec7d;
	dynaNullspace:Mat7d;	
	TorqueNullSpace:Vec7d; //joint torque for null space
	jntOptTor:LREAL; //joint 6 optimization torque
	jntTorqueSum:Vec7d;		
	jntImpTor:Vec7d;
	
	//master arm posture error variables
	posErr,posErrInBase,posErrInTcp:Vec3d;
	rotErr :Mat3d;
	errAngle : LREAL;
	errAxisLocal, errAxis,errAxis2,errAxisInBase,errAxisInTcp :Vec3d;
	masterPoseError,masterPoseErrorInTcp :Vec6d;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
//determine slave arm space position relative to endoscope
masterPos:=transform(i_shoulderPose,i_masterArm.simCartPose);
slavePos:=i_slaveStatus.m_curArmPose[i_slaveIdx];

//system parameters initial
IF (m_firstIn=TRUE) THEN
	m_firstIn:=FALSE;
	masterPosFirst:=masterPos;
	slavePosFirst:=slavePos;	
	m_ExpJ6Pos:=i_masterArm.curJntPos[6];	
END_IF

m_t:=m_t+g_armCtrlCycleTime;
IF (m_t<=0.050) THEN
	m_firstIn:=TRUE;
	RETURN;	
END_IF




//calculating slave arm position incresement，and determine master arm space position and posture
vecSub(slavePos.m_pos,slavePosFirst.m_pos,posInc);
vecMultiNum(posInc,1.0/m_endoMotionScale,posInc);
vecAdd(posInc,masterPosFirst.m_pos,ArmTarPos.m_pos);
ArmTarPos.m_rot:=slavePos.m_rot;



//calculating master arm position error and postrue error
vecSub(ArmTarPos.m_pos, masterPos.m_pos, PosErr);
matTranspose(masterPos.m_rot, tmpMat3d);
matMultiply(tmpMat3d, ArmTarPos.m_rot, rotErr);
rot2AngAxis(rotErr, angle=>errAngle, axis=>errAxisLocal);
matMultiVec(masterPos.m_rot, errAxisLocal, errAxis);



//transform the error to arm base coordinate
matTranspose(i_shoulderPose.m_rot,tmpMat3d); //transform matrix from eye to base
matMultiVec(tmpMat3d, PosErr,posErrInBase);
matMultiVec(tmpMat3d, errAxis,errAxis2);
vecMultiNum(errAxis2,errAngle,errAxisInBase);
FOR i:=1 TO 3 BY 1 DO
	masterPoseError[i]:=posErrInBase[i];
	masterPoseError[i+3]:=errAxisInBase[i];
END_FOR



//transform the error to TCP coordinate
matTranspose(i_masterArm.curCartPose.m_rot, rotInv);
matMultiVec(rotInv, posErrInBase, posErrInTcp);
matMultiVec(rotInv, errAxisInBase, errAxisInTcp);
FOR i:=1 TO 3 BY 1 DO
	masterPoseErrorInTcp[i]:=posErrInTcp[i];
	masterPoseErrorInTcp[i+3]:=errAxisInTcp[i];
END_FOR



//determine master arm space velocity in base coordinate
FOR i:=1 TO 3 DO
	vel[i]:=i_masterArm.curCartTwist[i];
	wVel[i]:=i_masterArm.curCartTwist[i+3];
	spatialVel[i]:=vel[i];
	spatialVel[i+3]:=wVel[i];
END_FOR



//transform master arm space velocity to tcp coordinate
matMultiVec(rotInv, vel, velLocal);
matMultiVec(rotInv, wVel, wVelLocal);
FOR i:=1 TO 3 DO
	spatialVelInTcp[i]:=velLocal[i];
	spatialVelInTcp[i+3]:=wVelLocal[i];
END_FOR



//Jacobian matrix
simJaco:=i_masterArm.Jaco;



//Based on the above pose deviation values, input them into the impedance control equation and derive the impedance joint torque value
IF (m_impCtrlInBase=TRUE) THEN
	FOR i:=1 TO 6 BY 1 DO
		spatialForBase[i]:=m_kpBase[i]*masterPoseError[i]-m_kdBase[i]*spatialVel[i]; //(-1)*err*(-1)=err
	END_FOR
	matMultiVec(i_masterArm.m_lambda, spatialForBase, spatialForTemp);
	matTranspose(simJaco,JacoT);
	matMultiVec(JacoT, spatialForTemp, jntImpTor);	
	
ELSE // impedance control in tcp coordinate
	FOR i:=1 TO 6 BY 1 DO
		spatialForTcp[i]:=m_kpTcp[i]*masterPoseErrorInTcp[i]-m_kdTcp[i]*spatialVelInTcp[i];
	END_FOR
	
	//Splitting spatial forces into two parts
	FOR i:=1 TO 3 BY 1 DO
		spatialForceP1[i]:=spatialForTcp[i];
		spatialForceP2[i]:=spatialForTcp[i+3];
	END_FOR
	
	// project torque back to base coordinate	
	matMultiVec(i_masterArm.curCartPose.m_rot, spatialForceP1, spatialForceP1Base);	
	matMultiVec(i_masterArm.curCartPose.m_rot, spatialForceP2, spatialForceP2Base);	
	
	FOR i:=1 TO 3 BY 1 DO
		spatialForBase[i]:=spatialForceP1Base[i];
		spatialForBase[i+3]:=spatialForceP2Base[i];
	END_FOR
	
	//compute joint space torque
	matTranspose(simJaco,JacoT);
	matMultiVec(JacoT, spatialForBase, jntImpTor);	
END_IF




//To ensure that joint 6 is in the appropriate position, a single joint impedance controller is constructed
jntOptTor:=m_Kp6*(m_ExpJ6Pos-i_masterArm.curJntPos[6])-m_Kd6*i_masterArm.curJntVel[6];
(*
//Project the torque of joint 6 onto null space
jntTorVec[6]:=jntOptTor;
dynaNullspace:=i_masterArm.dynaNullspace;
matMultiVec(dynaNullspace, jntTorVec, TorqueNullSpace);	

//Calculate the sum of impedance control torque and zero space torque
vecAdd(jntImpTor,TorqueNullSpace,jntTorqueSum);
m_cmdJntTrq:=jntTorqueSum;
*)
m_cmdJntTrq:=jntImpTor;
m_cmdJntTrq[6]:=jntOptTor;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="init" Id="{57b32a0e-e8b3-4703-9ef3-d40781548cc4}">
      <Declaration><![CDATA[// override this function in each exact controller
// NOTICE: set joint control mode here, and do some initialization if needed
METHOD PUBLIC init : BOOL
VAR_IN_OUT CONSTANT
	i_masterArm	:FB_MasterArm;
END_VAR
VAR_IN_OUT 
	r_masterArmCtrlCmd :ST_ArmCtrlCmds;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
SUPER^.Init(i_masterArm,r_masterArmCtrlCmd);

m_jntOPMode[1] := DriverOPMode_Trq;
m_jntOPMode[2] := DriverOPMode_Trq;
m_jntOPMode[3] := DriverOPMode_Trq;
m_jntOPMode[4] := DriverOPMode_Trq;
m_jntOPMode[5] := DriverOPMode_Trq;
m_jntOPMode[6] := DriverOPMode_Trq;
m_jntOPMode[7] := DriverOPMode_Trq;

m_firstIn:=TRUE;
m_t:=0;

// update commands to arm
copyCmds(r_masterArmCtrlCmd);

]]></ST>
      </Implementation>
    </Method>
    <Method Name="relativeAngle" Id="{4e04bc39-4042-4125-b6b8-eb31367798cc}">
      <Declaration><![CDATA[METHOD relativeAngle : bool
VAR_INPUT
	armId:INT;
	x:LREAL;
	y:LREAL;
END_VAR

VAR_OUTPUT
	angle:LREAL;
END_VAR

VAR
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[

angle:=atan2(y,x);
IF (armId=1) AND (angle<0) THEN
	angle:=angle+2*pi;
END_IF

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_StateCtrlEndoscope">
      <LineId Id="9" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlEndoscope.calcCmdJntPos">
      <LineId Id="14" Count="0" />
      <LineId Id="96" Count="1" />
      <LineId Id="111" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlEndoscope.calcCmdJntTrq">
      <LineId Id="415" Count="9" />
      <LineId Id="426" Count="0" />
      <LineId Id="428" Count="0" />
      <LineId Id="571" Count="0" />
      <LineId Id="429" Count="0" />
      <LineId Id="567" Count="0" />
      <LineId Id="570" Count="0" />
      <LineId Id="568" Count="1" />
      <LineId Id="566" Count="0" />
      <LineId Id="430" Count="7" />
      <LineId Id="441" Count="111" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlEndoscope.init">
      <LineId Id="13" Count="0" />
      <LineId Id="16" Count="8" />
      <LineId Id="37" Count="0" />
      <LineId Id="36" Count="0" />
      <LineId Id="47" Count="0" />
      <LineId Id="25" Count="1" />
      <LineId Id="14" Count="1" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="FB_StateCtrlEndoscope.relativeAngle">
      <LineId Id="15" Count="3" />
      <LineId Id="21" Count="1" />
      <LineId Id="19" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>